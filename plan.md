Perfect! Now I have all the context. Let me create a refined plan that builds a **universal webhook adapter pattern** (single module for all 4 tools) using YAML/JSON/HCL configuration — adaptable, extensible, user-friendly.

---

## Plan: Universal Webhook Adapter with Config-Driven Tool Integration (TDD + CodeUChain)

**TL;DR**: Build a single, reusable **webhook adapter framework** where each tool (GitHub, Jenkins, Terraform, Prometheus) is defined via simple YAML/JSON configs. Users can add new tools by creating configs — zero Python code changes. Uses CodeUChain for event routing, TDD for validation. All configs live in `config/webhooks/` and are validated against a JSON schema.

**Architecture**: 
- **Single adapter module** (`backend/src/components/adapters/webhook_adapter.py`) handles all tools
- **Config-driven tool registration** (`config/webhooks/tools/*.yaml`) — add tools via YAML, not code
- **Universal event format** (`WebhookEvent` model) — all tools translate payloads to same internal format
- **CodeUChain routing chains** — events routed through chains based on config
- **JSON Schema validation** (`schemas/webhook-config.schema.json`) — users can validate their own configs
- **Zero vendor lock-in** — add GitHub, Jenkins, Terraform, Prometheus with same pattern

**Inspirations from PLUGIN_ARCHITECTURE_VISION.md**:
- ✅ Configuration over code (users define tools via YAML, not Python)
- ✅ Community extensibility (any user can create `config/webhooks/tools/custom-tool.yaml`)
- ✅ Validation schemas (JSON Schema enforces correctness)
- ✅ Manifest-based discovery (each tool has a manifest)
- ✅ Privacy choice (public configs shared, private kept local)

---

## Steps (Detailed Breakdown):

### **Phase 0: Foundation — Universal Adapter Pattern (TDD RED → GREEN)**

1. **[RED] Write comprehensive tests first** (`backend/tests/unit/test_webhook_adapter.py`):
   - Test `WebhookConfigLoader` loads YAML/JSON/HCL configs
   - Test `UniversalWebhookAdapter.parse()` transforms GitHub payload → internal `WebhookEvent`
   - Test `UniversalWebhookAdapter.parse()` transforms Jenkins payload → same `WebhookEvent` format
   - Test `UniversalWebhookAdapter.parse()` transforms Terraform payload → same format
   - Test `UniversalWebhookAdapter.parse()` transforms Prometheus payload → same format
   - Test `ConfigValidator` validates configs against JSON schema
   - Test error cases: invalid config, missing required fields, unsupported tool
   - **RED**: All tests fail (classes don't exist yet)

2. **Define universal webhook event model** (`backend/src/models/webhook.py`):
   - Create `WebhookEvent` TypedDict with standardized fields:
     ```python
     class WebhookEvent(TypedDict):
         event_id: str              # UUID, generated by adapter
         tool: str                  # "github", "jenkins", "terraform", "prometheus"
         event_type: str            # "push", "build_completed", "plan", "alert_fired"
         timestamp: datetime
         source_url: str            # Link to event in original tool
         metadata: dict             # Tool-specific fields (repo, branch, job_name, etc.)
         payload: dict              # Original vendor payload (for debugging)
     ```
   - Create tool-agnostic event types: `PushEvent`, `BuildCompletedEvent`, `PlanEvent`, `AlertEvent`

3. **Create webhook config schema** (`schemas/webhook-config.schema.json`):
   - JSON Schema defining what a valid tool config looks like
   - Required fields: `id`, `type`, `integration.webhooks`
   - Optional fields: `ui`, `data_mapping`, `validation`
   - Allows users to validate their own configs: `python -m jsonschema config/webhooks/tools/my-tool.yaml`

4. **Create universal adapter** (`backend/src/components/adapters/webhook_adapter.py`):
   ```python
   class UniversalWebhookAdapter:
       def __init__(self, config: ToolConfig):
           self.config = config
           self.tool_id = config['metadata']['id']
       
       async def parse(self, payload: dict, headers: dict) -> WebhookEvent:
           # 1. Verify signature (uses config's verification method)
           # 2. Extract tool-specific fields using config's data_mapping
           # 3. Normalize to WebhookEvent format
           # 4. Return universal event
   ```
   - **Single adapter** works for all tools (GitHub, Jenkins, Terraform, Prometheus, custom tools)
   - **Data mapping via config** — config defines how to extract fields from vendor payload
   - **Signature verification via config** — config defines verification method (HMAC-SHA256, token, etc.)

5. **Create config loader** (`backend/src/services/webhook_config_loader.py`):
   ```python
   class WebhookConfigLoader:
       async def load_config(self, tool_id: str) -> ToolConfig:
           # 1. Check config/webhooks/tools/{tool_id}.yaml
           # 2. Check config/webhooks/tools-private/{tool_id}.yaml
           # 3. Validate against JSON schema
           # 4. Return parsed config
       
       async def list_tools(self) -> List[str]:
           # Discover all tool configs in config/webhooks/tools/
       
       async def validate_config(self, path: str) -> ValidationResult:
           # Validate a config file against schema
   ```

6. **Create FastAPI webhook router** (`backend/src/webhook_routes.py`):
   ```python
   @router.post("/api/webhooks/<tool_id>")
   async def receive_webhook(tool_id: str, request: Request):
       # 1. Load config for tool_id
       # 2. Create adapter with config
       # 3. Parse payload (verify signature, normalize)
       # 4. Route to handler chain
       # 5. Return 200 OK or 400 Bad Request
   ```
   - **Single endpoint** handles all tools: `/api/webhooks/github`, `/api/webhooks/jenkins`, etc.
   - No hardcoded tool-specific logic (all in config)

7. **Write tool configs** (`config/webhooks/tools/*.yaml`):
   - Create `config/webhooks/tools/github.yaml` (GitHub Actions)
   - Create `config/webhooks/tools/jenkins.yaml` (Jenkins)
   - Create `config/webhooks/tools/terraform.yaml` (Terraform)
   - Create `config/webhooks/tools/prometheus.yaml` (Prometheus)
   - Each config defines: webhook verification, event type mapping, data extraction rules

---

### **Phase 1: GitHub Webhook Adapter (TDD RED → GREEN)**

8. **Create GitHub tool config** (`config/webhooks/tools/github.yaml`):
   ```yaml
   version: 1.0.0
   type: tool
   
   metadata:
     id: github
     name: GitHub / GitHub Actions
     description: Receive push, pull request, and workflow events from GitHub
     category: version-control / ci-cd
     
   integration:
     webhooks:
       enabled: true
       endpoint: /api/webhooks/github
       verification:
         method: hmac-sha256
         header: X-Hub-Signature-256
         secret_env_var: GITHUB_WEBHOOK_SECRET
       
       events:
         push:
           http_event_header: X-GitHub-Event
           header_value: push
           data_mapping:
             event_type: "push"
             repository: $.repository.full_name
             branch: $.ref
             commit_sha: $.head_commit.id
             commit_message: $.head_commit.message
             author: $.pusher.name
             # ... more field mappings
         
         pull_request:
           http_event_header: X-GitHub-Event
           header_value: pull_request
           data_mapping:
             event_type: "pull_request"
             repository: $.pull_request.head.repo.full_name
             # ... more field mappings
   
   features:
     auto_job_creation: true      # Create Job on push
     auto_deployment: false
   
   contribution:
     author: orchestrate-solutions
     license: MIT
     allow_forks: true
   ```

9. **Write RED tests for GitHub** (`backend/tests/unit/test_github_webhook_adapter.py`):
   - Test `GitHubConfigLoader` loads `config/webhooks/tools/github.yaml`
   - Test `UniversalWebhookAdapter` with GitHub config:
     - Verify HMAC-SHA256 signature (X-Hub-Signature-256)
     - Extract event type from X-GitHub-Event header
     - Map payload fields using config's `data_mapping`
     - Return normalized `WebhookEvent`
   - Test error cases: invalid signature, missing fields, unsupported event type
   - **RED**: Tests fail

10. **Implement GitHub adapter** (`backend/src/components/adapters/github_adapter.py`):
    ```python
    class GitHubAdapter(UniversalWebhookAdapter):
        async def verify_signature(self, payload: bytes, signature: str) -> bool:
            # HMAC-SHA256 verification
            expected = "sha256=" + hmac.new(
                self.config['integration']['webhooks']['verification']['secret'].encode(),
                payload,
                hashlib.sha256
            ).hexdigest()
            return hmac.compare_digest(expected, signature)
        
        async def extract_event_type(self, headers: dict) -> str:
            # Extract from X-GitHub-Event
            return headers.get('X-GitHub-Event')
        
        async def extract_fields(self, payload: dict) -> dict:
            # Use config's data_mapping to extract fields
            # (generic, works for any tool)
    ```
    - **Inherits from UniversalWebhookAdapter** (no duplication)
    - Uses config-driven data mapping (JSON path expressions in config)
    - **GREEN**: All tests pass

---

### **Phase 2: Jenkins + Terraform Webhooks (Scale Pattern)**

11. **Create Jenkins tool config** (`config/webhooks/tools/jenkins.yaml`):
    ```yaml
    version: 1.0.0
    type: tool
    
    metadata:
      id: jenkins
      name: Jenkins CI/CD
      description: Receive build events from Jenkins
      category: ci-cd
      
    integration:
      webhooks:
        enabled: true
        endpoint: /api/webhooks/jenkins
        verification:
          method: token
          header: X-Jenkins-Token
          secret_env_var: JENKINS_WEBHOOK_TOKEN
        
        events:
          build_completed:
            http_event_header: X-Jenkins-Event
            header_value: build_completed
            data_mapping:
              event_type: "build_completed"
              job_name: $.build.name
              build_number: $.build.number
              status: $.build.status
              # ... more mappings
    ```

12. **Create Terraform tool config** (`config/webhooks/tools/terraform.yaml`):
    ```yaml
    version: 1.0.0
    type: tool
    
    metadata:
      id: terraform
      name: Terraform Cloud
      description: Receive plan and apply events from Terraform Cloud
      category: infrastructure-as-code
      
    integration:
      webhooks:
        enabled: true
        endpoint: /api/webhooks/terraform
        verification:
          method: signature
          header: X-Terraform-Signature
          secret_env_var: TERRAFORM_WEBHOOK_SECRET
        
        events:
          plan_generated:
            data_mapping:
              event_type: "plan"
              workspace: $.data.attributes.name
              resources_changed: $.data.attributes.resources_added
              # ... more mappings
    ```

13. **Write RED tests for Jenkins + Terraform** (`backend/tests/unit/test_jenkins_terraform_adapters.py`):
    - Verify both tools work with `UniversalWebhookAdapter` + config
    - No new Python classes needed (reuse universal adapter)
    - **RED**: Tests fail until configs are properly loaded

14. **Implement via config + universal adapter**:
    - Both tools use `UniversalWebhookAdapter` class (no new classes)
    - Configs define differences (verification method, event types, data mapping)
    - **GREEN**: All tests pass

---

### **Phase 3: Prometheus + Event Storage & Routing**

15. **Create Prometheus tool config** (`config/webhooks/tools/prometheus.yaml`):
    ```yaml
    version: 1.0.0
    type: tool
    
    metadata:
      id: prometheus
      name: Prometheus AlertManager
      description: Receive alerts from Prometheus AlertManager
      category: monitoring
      
    integration:
      webhooks:
        enabled: true
        endpoint: /api/webhooks/prometheus
        verification:
          method: none  # AlertManager doesn't support signatures natively
        
        events:
          alert_fired:
            data_mapping:
              event_type: "alert_fired"
              alerts: $.alerts[*]
              severity: $.alerts[0].labels.severity
              # ... more mappings
    ```

16. **Create CodeUChain event handler chains** (`backend/src/components/chains/webhook_chains.py`):
    ```python
    class WebhookEventChain:
        def __init__(self, store: WebhookEventStoreInterface):
            self.chain = Chain()
            self.chain.add_link(LoadToolConfigLink(), "load_config")
            self.chain.add_link(AdaptPayloadLink(), "adapt")
            self.chain.add_link(ValidateEventLink(), "validate")
            self.chain.add_link(RouteEventLink(), "route")
            self.chain.add_link(StoreWebhookEventLink(store), "store")
        
        async def run(self, tool_id: str, payload: dict, headers: dict) -> dict:
            ctx = Context({
                "tool_id": tool_id,
                "payload": payload,
                "headers": headers
            })
            result = await self.chain.run(ctx)
            return result.to_dict()
    ```

17. **Create WebhookEventStore interface** (`backend/src/db/webhook_store.py`):
    ```python
    class WebhookEventStoreInterface(ABC):
        @abstractmethod
        async def save_event(self, event: WebhookEvent) -> str: ...
        
        @abstractmethod
        async def get_event(self, event_id: str) -> Optional[WebhookEvent]: ...
        
        @abstractmethod
        async def list_events(self, tool: str, limit: int) -> List[WebhookEvent]: ...
    ```
    - Both in-memory and DynamoDB implementations

18. **Create webhook manifest for user-created tools** (`config/webhooks/tools/example-custom-tool.yaml`):
    - Template users can copy and customize
    - Demonstrates all configuration options
    - Includes comments explaining each field

---

### **Phase 4: Integration Tests + User Documentation + Error Handling**

19. **Write E2E webhook tests** (`backend/tests/integration/test_webhook_flows.py`):
    - GitHub push → create Job
    - Jenkins build_completed → create Deployment
    - Prometheus alert_fired → create Alert + route to Slack
    - Terraform plan → create InfrastructureChange

20. **Create webhook configuration documentation** (`docs/webhooks/README.md`):
    - **How to Add a New Tool** (copy template, fill in fields, test locally)
    - **Configuration Reference** (all config options explained)
    - **Examples** (GitHub, Jenkins, Terraform, Prometheus fully annotated)
    - **Data Mapping Guide** (how to write JSON path expressions)
    - **Verification Methods** (HMAC, token, signature, none)

21. **Create CLI tool for config validation** (`backend/scripts/validate-webhook-config.py`):
    ```bash
    # Validate a single config
    python scripts/validate-webhook-config.py config/webhooks/tools/github.yaml
    
    # Validate all configs
    python scripts/validate-webhook-config.py --all
    
    # Test webhook locally
    python scripts/validate-webhook-config.py --test config/webhooks/tools/github.yaml test-payload.json
    ```

22. **Add error handling + retry logic** (`backend/src/components/links/webhook_links.py`):
    - Create `HandleWebhookErrorLink` (catch exceptions, store error)
    - Create `RetryWebhookLink` (DynamoDB webhook_errors table with retry count)
    - Dead-letter queue for failed events (max 3 retries)

23. **Frontend: Webhook Management Dashboard** (`src/components/webhooks/WebhookConfig.tsx`):
    - Display enabled/disabled tools (from config)
    - Upload custom tool configs
    - View webhook events (recent, filtered by tool)
    - Replay events for testing
    - Test webhook endpoint (send mock payload)

---

## Config Structure Explained (User-Friendly)

### **Minimal GitHub Config (30 lines)**

```yaml
version: 1.0.0
type: tool

metadata:
  id: github
  name: GitHub
  category: version-control

integration:
  webhooks:
    enabled: true
    endpoint: /api/webhooks/github
    verification:
      method: hmac-sha256
      header: X-Hub-Signature-256
      secret_env_var: GITHUB_WEBHOOK_SECRET
    
    events:
      push:
        http_event_header: X-GitHub-Event
        header_value: push
        data_mapping:
          event_type: "push"
          repository: $.repository.full_name
          branch: $.ref
          commit_sha: $.head_commit.id
          author: $.pusher.name
```

### **How Users Create Custom Tool**

```bash
# 1. Copy template
cp config/webhooks/tools/template.yaml config/webhooks/tools/my-custom-tool.yaml

# 2. Edit the YAML with your tool's webhook format
# 3. Test locally
python scripts/validate-webhook-config.py config/webhooks/tools/my-custom-tool.yaml

# 4. Upload test payload
python scripts/validate-webhook-config.py --test config/webhooks/tools/my-custom-tool.yaml test-payload.json

# 5. Deploy (no code changes needed!)
```

---

## Directory Structure

```
config/webhooks/
├── webhooks-config.schema.json          # JSON Schema for validation
├── tools/                               # Public tool configs (in git)
│   ├── github.yaml
│   ├── jenkins.yaml
│   ├── terraform.yaml
│   ├── prometheus.yaml
│   ├── template.yaml                    # Template for users to copy
│   └── README.md                        # How to add a tool
├── tools-private/                       # Private tool configs (not in git)
│   └── my-company-tool.yaml
└── README.md                            # Getting started

backend/src/components/adapters/
├── __init__.py
├── webhook_adapter.py                   # Universal adapter (main logic)
└── tool_adapters/                       # Tool-specific helpers (if needed)
    ├── __init__.py
    └── github.py                        # GitHub-specific helpers (optional)

backend/src/services/
├── webhook_config_loader.py             # Load & validate configs
└── webhook_event_bus.py                 # Route events

backend/src/db/
├── webhook_store.py                     # Store interface + implementations
└── webhook_event.py                     # Event model

backend/tests/unit/
├── test_webhook_adapter.py              # Universal adapter tests
├── test_github_webhook.py               # GitHub-specific tests
├── test_jenkins_webhook.py              # Jenkins tests
├── test_terraform_webhook.py            # Terraform tests
└── test_prometheus_webhook.py           # Prometheus tests

docs/webhooks/
├── README.md                            # Getting started
├── CONFIGURATION_REFERENCE.md           # All config options
├── EXAMPLES.md                          # Annotated examples
└── ADDING_NEW_TOOL.md                   # Step-by-step guide
```

---

## Open Questions:

1. **YAML vs JSON vs HCL**: Start with YAML (human-friendly), support JSON (programmatic), add HCL (Terraform users)? → **Recommend**: YAML primary, auto-convert to/from JSON
   
2. **Schema versioning**: Configs should declare schema version (1.0, 2.0)? Migrations? → **Recommend**: Yes, loader handles backwards compatibility

3. **Private configs**: Store private tool configs in `config/webhooks/tools-private/` (gitignored)? → **Recommend**: Yes, supports custom tools

4. **User contributions**: Where do community-contributed tool configs live? → **Recommend**: GitHub discussion → PR → merged to `config/webhooks/tools/`

5. **CLI vs Dashboard**: Validate configs via CLI or web UI? → **Recommend**: Both — CLI for developers, UI for ops

---

## Deliverables per Phase:

| Phase | Duration | Tests | Files | Coverage |
|-------|----------|-------|-------|----------|
| **Phase 0** | 3 hrs | 24 | Universal adapter + schema | 100% |
| **Phase 1** | 3 hrs | 18 | GitHub config + tests | 100% |
| **Phase 2** | 2 hrs | 16 | Jenkins + Terraform configs | 100% |
| **Phase 3** | 2 hrs | 12 | Prometheus config + storage | 100% |
| **Phase 4** | 2 hrs | 20+ | E2E tests + docs + CLI | 100% |
| **TOTAL** | **12 hrs** | **90+ tests** | **Config-driven system** | **100%** |

---

**Ready for review?** This plan delivers:

✅ **Single reusable adapter** (works for all 4 tools + any future tool)  
✅ **Config-driven extensibility** (users add tools via YAML, zero Python changes)  
✅ **Universal event format** (GitHub, Jenkins, Terraform, Prometheus → same internal format)  
✅ **Validation schemas** (JSON Schema ensures correctness, users can validate)  
✅ **Community-friendly** (templates, docs, CLI tools make it easy)  
✅ **YAML/JSON/HCL support** (start with YAML, scale to other formats)  
✅ **Privacy choice** (public configs in git, private configs ignored)  
✅ **Full TDD coverage** (90+ tests, all phases)  
✅ **Production-ready** (error handling, retry logic, monitoring)  

**Ready to proceed?** Shall I update `#todos` and create detailed markdown planning doc?